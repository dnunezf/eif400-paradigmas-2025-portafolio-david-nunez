\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{caption}
\usepackage{float}
\usepackage{enumitem}
\geometry{margin=1in}
\usepackage{listings}
\usepackage{xcolor}

% Colores personalizados
\definecolor{keywordcolor}{RGB}{0,0,180}
\definecolor{ndkeywordcolor}{RGB}{128,0,128}
\definecolor{stringcolor}{RGB}{163,21,21}
\definecolor{commentcolor}{RGB}{0,128,0}

% --- Definición de Java ---
\lstdefinelanguage{Java}{
	keywords={abstract, assert, boolean, break, byte, case, catch, char, class, const, continue, default, do, double, else, enum, extends, final, finally, float, for, goto, if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while},
	keywordstyle=\color{keywordcolor}\bfseries,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{commentcolor}\ttfamily,
	stringstyle=\color{stringcolor}\ttfamily,
	morestring=[b]",
	morestring=[b]'
}

% --- Definición de JavaScript ---
\lstdefinelanguage{JavaScript}{
	keywords={break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof,
		new, return, switch, this, throw, try, typeof, var, void, while, with, const, let},
	keywordstyle=\color{keywordcolor}\bfseries,
	ndkeywords={class, export, boolean, throw, implements, import, this},
	ndkeywordstyle=\color{ndkeywordcolor}\bfseries,
	identifierstyle=\color{black},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{commentcolor}\ttfamily,
	stringstyle=\color{stringcolor}\ttfamily,
	morestring=[b]',
	morestring=[b]"
}

% Configuración global
\lstset{
	basicstyle=\ttfamily\small,
	numbers=left,
	numberstyle=\tiny\color{gray},
	stepnumber=1,
	numbersep=5pt,
	showstringspaces=false,
	tabsize=4,
	breaklines=true,
	captionpos=b,
	frame=single,
	frameround=tttt
}

\title{Tarea Independiente 09/10/2025}
\author{David Núñez Franco}
\date{\today}

\begin{document}
	
	\maketitle
	
	\section*{Inventario de Conceptos Claves}
	
	\begin{itemize}
		\item Visitador de AST de código que genera un AST de tipos
		\item Tipo como AST
		\item Compatibilidad de tipos
		\item Scope como ambiente (environment, o Env). 
		\item Modelo de JS como máquina asincrónica (monohilo, pila cola)
		\item Loop de eventos (Event-loop)
		\item Timers
	\end{itemize}
	
	\section*{Ejercicio 0}
	
	\begin{quote}
		Estudie el mini-typer entregado y añada el caso de TupleType.
	\end{quote}
	
	\subsection*{Solución}
	
	\begin{lstlisting}[language=JavaScript,caption={ast.mjs}]
		// types as AST
		export class Type extends Node {
			toString() {
				return this.head.toString();
			}
		}
		
		export class IntType extends Type {
			constructor() {
				super("int");
			}
		}
		
		export class AnyType extends Type {
			constructor() {
				super("any");
			}
		}
		
		export class TupleType extends Type {
			constructor(...elemTypes) {
				super("tuple", ...elemTypes);
			}
			get elems() {
				return this.children;
			}
			toString() {
				return `(${this.elems.map((t) => t.toString()).join(", ")})`;
			}
		}
		
		export class AstPrintVisitor extends Visitor {
			visit(node) {
				if (!node) {
					return;
				}
				if (node instanceof Num) {
					console.log(node.value);
					return;
				}
				if (node instanceof Id) {
					console.log(node.name);
					return;
				}
				
				if (node instanceof Type) {
					console.log(node.toString());
					return;
				}
				
				if (node instanceof UnaryOp) {
					console.log(node.oper.name);
					console.log(node.expr.accept(this));
					return;
				}
			}
		}
	\end{lstlisting}
	
	\begin{lstlisting}[language=JavaScript,caption={main.mjs}]
		function test_case_tuple_type() {
			const tInt = new IntType();
			const tAny = new AnyType();
			const tPair = new TupleType(tInt, tInt);
			const tTriple = new TupleType(tInt, tAny, tPair);
			
			console.log("TupleType pair =", tPair.toString());
			console.log("TupleType triple =", tTriple.toString());
			
			const printer = new AstPrintVisitor();
			tTriple.accept(printer);
		}
	\end{lstlisting}
	
	\begin{lstlisting}[language=JavaScript,caption={output}]
		TupleType pair = (int, int)
		TupleType triple = (int, any, (int, int))
		(int, any, (int, int))
	\end{lstlisting}
	
	\section*{Ejercicio 2}
	
	\begin{verbatim}
		Considere este código
		function print_json(user=1){
			fetch(`https://jsonplaceholder.typicode.com/todos/${user}`)
			.then(response => response.json())
			.then(json => console.log(json))
			.catch(err => console.error(err))
		}
		Reescriba usando código asincrónico imperativo async/await de manera equivalente.
	\end{verbatim}
	
	\subsection*{Solución}
	
	\begin{lstlisting}[language=JavaScript,caption={async/wait code}]
		async function print_json(user = 1) {
			try {
				const response = await fetch(
				`https://jsonplaceholder.typicode.com/todos/${user}`
				);
				const json = await response.json();
				console.log(json);
			} catch (err) {
				console.error(err);
			}
		}
	\end{lstlisting}
	
	\section*{Ejercicio 3}
	
	\begin{verbatim}
		Escriba en JS una funcción asincrónica repeat(action, conditon, secs) que cumpla lo siguiente:
		action y condition son lambdas asincrónicas tales que:
		action() devuelve una Promise que resuelve con un  value.
		Entonces condition(value) devuelve una Promise que resuelve con true o false.
		La función repeat debe esperar al menos secs segundos antes de comenzar.
		Ejecuta repetidamente action(). Se detiene cuando el resultado devuelto por action cumple con el predicado condition.
		Al terminar repeat retornará el primer value devuelto por action que cumplió condition.
		Use async/await y por ende (para variar) código imperativo en este caso.
		Ejemplo de uso: genere el primer random mayor que .9,
		repeat(
		async () => Math.random(),
		async x => x > 0.9,  
		2                     // espere 2 segundos antes de emepzar a generar
		).then(x => console.log(`First value found ${x.toFixed(3)}`))
	\end{verbatim}
	
	\subsection*{Solución}
	
	\begin{lstlisting}[language=JavaScript]
		async function repeat(action, condition, secs) {
			// esperar al menos secs segundos antes de iniciar
			await new Promise((resolve) => setTimeout(resolve, secs * 1000)); // crea la espera inicial
			
			// bucle controlado por la condicion
			// cada iteracion espera la resolucion de action(), y luego evalua condition(value)
			// cuando condition devuelve true, se retorna ese valor y la funcion termina
			while (true) {
				const value = await action();
				const ok = await condition(value);
				if (ok) return value;
			}
		}
		
		repeat(
		async () => Math.random(),
		async (x) => x > 0.9,
		2
		).then((x) => console.log(`First value found ${x.toFixed(3)}`));
	\end{lstlisting}
	
\end{document}
